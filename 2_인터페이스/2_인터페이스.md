##### Typescript 핸드북 study.log

# 인터페이스

## 1. 인터페이스의 첫 이해

인터페이스는 여러 가지 타입을 갖는 `properties`로 이루어진 새로운 타입을 정의하는 것과 유사하다.  
프로퍼티와 메소드를 가질 수 있다는 점에서 클래스와 유사하지만, **직접 인스턴스를 생성할 수 없고 모든 메소드가 추상 메소드**라는 점에서 차이가 있다. 추상 클래스의 추상 메소드와 달리 `abstract` 키워드를 사용하지 않는다.

아래 함수는 `string` 타입의 `lable`읠 갖는 객체를 매개변수로 받는다.

```typescript
function printLabel(labeledObj: { label: string }) {
  console.log(labeledObj.label);
}
```

<br>같은 함수를 인터페이스로 다시 작성해 보면 다음과 같다.

```typescript
interface LabeledValue {
  lable: string;
}

function printLabel(labeledObj: LabeledValue) {
  console.log(labeledObj.lebel);
}
```

<br>타입 검사에서, 프로퍼티의 순서에 상관없이 인터페이스가 요구하는 프로퍼티들이 존재하는지, 프로퍼티들이 요구하는 타입을 가졌는지만 확인한다.

## 2. 선택적 프로퍼티 (Optional Properties)

인터페이스의 몇몇 프로퍼티들은 어떤 조건에서만 존재하거나, 아예 없을 수도 있다. 이때 선택적 프로퍼티를 이용한다.  
선언에서 프로퍼티 이름 끝에 `?`를 붙여 표시하면 선택적 프로퍼티임을 명시할 수 있고, 이를 통해 인터페이스에 속하지 않은 프로퍼티의 사용은 방지하면서, 사용 가능한 속성을 기술할 수 있다.

```typescript
interface SqareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = { color: "white", area: 100 };
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  if (config.clor) {
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
  }
  return newSquare;
}
```

## 3. 읽기 전용 프로퍼티 (Readonly Properties)

읽기 전용 프로퍼티는 객체가 처음 생성될 때에만 수정 가능하고, 이후에는 수정이 불가능하다. 프로퍼티 이름 앞에 `readonly`를 넣어서 이를 지정할 수 있다.

`const`와 헷갈릴 수 있는데, 변수의 경우 `const`를 사용하고, 프로퍼티의 경우 `readonly`를 사용한다.

```typescript
interface Point {
  readonly x: number;
  readonly y: number;
}

let p1: Point = { x: 10, y: 20 };
p1.x = 5; // 오류 발생
```

<br>Typescript에서 제공하는 `ReadonlyArray<T>` 타입을 이용할 수도 있다. 이는 모든 변경 메서드가 제거된 `Array<T>`와 동일하다.

```typescript
lea numArr: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = numArr;

numArr[0] = 12; // 오류
numArr = ro; // 오류
```

<br>위 코드 마지막 줄에서 알 수 있듯 `ReadonlyArray`를 일반 배열에 재할당하는 것은 일반적으로 불가능하지만, 타입 단언(type assertion)으로 오버라이드하는 것은 가능하다.

```typescript
numArr = ro as number[];
```

## 4. 초과 프로퍼티 검사 (Excess Property Checks)

Typescript는 인터페이스에 속하지 않은 프로퍼티가 사용되는 것은 막지만, 사용되지 않는 프로퍼티에 대한 제제는 하지 않는다. 하지만 선택적 프로퍼티와 결합되는 경우 이는 에러를 발생시킬 수 있다.

```typescript
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = { color: "white", area: 100 };
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({ colorCode: "#D1180B", width: 100 });
// error: Object literal may only specify known properties, but 'colorCode' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
```

<br>객체 리터럴을 다른 변수에 할당하거나 인수로 전달할 때, 초과 프로퍼티 검사를 거친다. 만약 객체 리터럴이 "대상 타입(`target type`)"이 갖고 있지 않은 프로퍼티를 가지고 있으면 에러가 발생한다.  
<br>타입 단언을 사용하면 이 검사를 피할 수 있다.

```typescript
let mySquare = createSquare({ sidth: 100, opacity: 0.5 } as SquareConfig);
```

<br>하지만, 추가 프로퍼티가 있음을 확신한다면 **문자열 인덱스 서명 (string index signature)**을 추가하는 것이 더 나은 방법이다. 만약 `SquareConfig`가 또 다른 프로퍼티를 가질 수 있다면, 다음과 같이 나타낼 수 있다.

```typescript
interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
```

<br>위 코드에서 `SquareConfig`는 `color`나 `width`가 아닌 여러 다른 프로퍼티들을 타입에 관계없이 가질 수 있다.

이 검사를 피하는 마지막 방법은 **객체를 다른 변수에 할당하는 것**이다.

```typescript
let squareOptions = { colorCode: "#D1180B", width: 100 };
let mySquare = createSquare(squareOptions);
```

<br>`squareOptions`와 `SquareConfig` 사이에 `width`라는 공통 프로퍼티가 있기 때문에 위와 같은 방법이 가능하다. 만약 공통 프로퍼티가 없는 경우, 위와 같은 방법을 사용할 수 없다.

## 5. 함수 타입 (Function Types)

인터페이스는 함수의 타입도 설명할 수 있다.

```typescript
interface SearchFunc {
  (source: string, subString: string): boolean;
}
```

이렇게 정의된 함수 인터페이스는 다른 인터페이스와 동일하게 사용할 수 있다.  
이때 타입 검사 과정에서 매개변수의 이름이 같지 않아도 상관없다.

```typescript
let mySearch: SearchFunc;

mySearch1 = function (source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
};

let mySearch2: SearchFunc;
mySearch2 = function (src: string, sub: string): boolean {
  let result = src.search(sub);
  return result > -1;
};
```

<br>함수의 매개변수들은 같은 위치에 대응되는 매개변수끼리 하나씩 검사한다. 타입을 전혀 지정하지 않은 아래 예제의 경우 `SearchFunc` 타입의 변수로 직접 함수 값이 할당되었기 때문에 Typescript의 문맥상 타이핑 (contextual typing)이 인수 타입을 추론할 수 있다.

```typescript
let mySearch: SearchFunc;
mySearch = function (src, sub) {
  let result = src.search(sub);
  return result > -1;
};
```

만약 `mySearch` 함수가 숫자나 문자열을 반환한다면, 반환 타입이 `SearchFunc`인터페이스에 정의된 반환 타입과 일치하지 않는다는 내용의 에러가 발생한다.

## 6. 인덱서블 타입 (Indexable Types)

함수 타입과 유사하게, `a[10]`이나 `ageMap["daniel"]`처럼 타입을 인덱스로도 기술할 수 있는데, 이때 인덱스 서명은 `string`과 `number` 타입만 지원한다.

```typescript
interface StringArray {
  [index: number]: string;
}

interface NumberArray {
  [iString: string]: number;
}
```

<br>`string`과 `number` 두 타입을 동시에 사용할 것이라면 주의해야 하는데, `number`로 인덱싱을 해도 Javascript에서 이를 `string`으로 변환하기 때문이다. 즉 `number` 타입의 `100`으로 인덱싱하는 것은 `string`타입의 `"100"`으로 인덱싱하는 것과 같다.  
<br>문자열 인덱스는 사전과 같은 패턴을 기술하는 데 좋은 방법이지만, 모든 프로퍼티들이 반환 타입과 일치하도록 강제한다. 하지만 인덱스 시그니처가 프로퍼티 타입들의 합집합이라면 다른 타입의 프로퍼티들도 허용할 수 있다.

```typescript
interface NumberDictionary {
  [index: string]: number | string;
  length: number;
  name: string; // [index: string]: number로 정의한 경우 오류 발생
}
```

<br>인덱스의 할당을 막고 싶다면 인덱스 시그니처를 `readonly`로 만들 수도 있다.

```typescript
interface ReadonlyStringArray {
  readonly [index: number]: string;
}
```

## 7. 클래스 타입 (Class Types)

클래스의 형식을 명시적으로 지정하는 인터페이스는 `C#`이나 `JAVA`에서와 동일한 방법으로 사용할 수 있다. 이때 인터페이스는 클래스의 `public` 부분만을 기술하므로 클래스 인스턴스의 `private`에서는 특정 타입이 있는지 검사할 수 없다.

```typescript
interface ClockInterface {
  currentTime: Date;
  setTime(d: Date): void;
}

class Clock implements ClockInterface {
  currentTime: Date = new Date();
  setTime(d: date) {
    this.currentTime = d;
  }

  constructor(h: number, m: number) {}
}
```

### 클래스의 static과 instance의 차이점

클래스는 `static`타입과 `instance`타입 둘 중 하나의 타입을 가진다. 이때 인스턴스는 `new` 연산자와 함께 호출되면서 생성되는 객체를 말하고, 스태틱은 클래스의 전역 멤버를 말한다.
<br>클래스가 인터페이스를 구현할 때 클래스의 인스턴스만 검사하기 때문에, `static`은 이 검사에 포함되지 않는다. 때문에 생성자와 같은 스태틱은 아래 예제와 같이 직접 다뤄줘야 한다.

```typescript
// 생성자 정의
interface ClockConstructor {
  new (hour: number, minute: number): ClockInterface;
}

// 인스턴스 메서드를 정의하는 두 인터페이스 정의
interface ClockInterface {
  tick(): void;
}

// 인자로 받은 타입의 인스턴스를 생성하는 함수
function createClock(
  ctor: ClockConstructor,
  hour: number,
  minute: number
): ClockInterface {
  return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
    console.log("beep beep");
  }
}
class AnalogClock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
    console.log("tik tak tok");
  }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
```

<br>간단하게 클래스 표현을 사용할 수도 있다.

```typescript
interface ClockConstructor {
  new (hour: number, minute: number);
}

interface ClockInterface {
  tick();
}

const Clock: ClockConstructor = class Clock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
    console.log("beep beep");
  }
};
```

## 8. 인터페이스 확장 (Extending Interfaces)

클래스와 동일하게 인터페이스도 확장(Extend)이 가능하다. 인터페이스를 재사용해 다른 인터페이스를 구현할 수 있다는 뜻인데, 여러 인터페이스를 동시에 확장할 수도 있다.

```typescript
interface Shape {
  color: string;
}

interface PenStroke {
  penWidth: number;
}

interface Square extends Shape, PenStroke {
  sideLength: number;
}
```

## 9. 하이브리드 타입 (Hybrid Types)

인터페이스에는 객체와 함수에 대한 정의가 동시에 들어갈 수 있다.

```typescript
interface Counter {
  (start: number): string;
  interval: number;
  reset(): void;
}

function getCounter(): Counter {
  let counter = function (start: number) {} as Counter;
  counter.interval = 123;
  counter.reset = function () {};
  return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

위 예제에서, 객체 `c`는 함수와 객체의 역할을 모두 수행한다.

## 10. 클래스를 확장한 인터페이스 (Interfaces Extending Classes)

인터페이스 타입이 클래스 타입을 확장하면 클래스의 `private`와 `protected`멤버를 포함한 모든 멤버를 상속받지만, 구현은 상속받지 않는다.  
`private` 또는 `protected` 멤버를 포함한 클래스를 확장한 경우, 인터페이스 타입은 해당 클래스(또는 하위 클래스)에 의해서만 구현될 수 있다.

```typescript
class Control {
  private state: any;
}

interface SelectableControl extends Control {
  select(): void;
}

class Button extends Control implements SelectableControl {
  select() {}
}

class TextBox extends Control {
  select() {}
}

// Error: Property 'state' is missing in type 'Image'.
class Image implements SelectableControl {
  private state: any;
  select() {}
}
```

<br>위 예제에서 `SelectableControl`은 `Control`의 모든 멤버를 가지고 있다. 그리고 멤버 중 `state`는 `private` 멤버이기 때문에, `SelectableControl`을 구현하는 것은 오직 `Control`과 그 자식에게만 가능하다.  
하지만 `Image`는 `Control`의 자식이 아니다. 따라서 `SelectableControl`을 구현하려고 하면 오류가 발생한다.
