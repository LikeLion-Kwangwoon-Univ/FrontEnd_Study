### 불리언 ( #Boolean)

```typescript
let isDone: boolean = false;
```

### 숫자 ( #Number)

```typescript
let decimal: number = 6; // 10진수
let hex: number = 0xf00d; // 16진수
let binary: number = 0b1010; // 2진수
let octal: number = 0o744; // 8진수
```

### 문자열 ( #String)

```typescript
let color: string = "blue";
let intro: sentense = `my color : ${color}`;
```

### 배열 ( #Array)

```typescript
let list: number[] = [1, 2, 3];

// with generic
let list: Array<number> = [1, 2, 3];
```

### 튜플 ( #Tuple)

```Typescript
let x: [string, number];

x = ["hello", 10];
```

주의 ! 정해진 인덱스 외에 다른 인덱스 요소에 접근할 수 없다.

### 열거 ( #Enum)

```typescript
enum Color {
    Red,
    Green,
    Blue,
}

let c: Color = Color.Green; // 1
```

-   default: 0부터 맴버들의 번호를 매김
-   시작 번호를 수동으로 바꿔줄 수 있음

#### 유용한 Enum의 기능

```typescript
enum Color {
    Red,
    Green,
    Blue,
}
let colorName: string = Color[2];
// colorName: "Blue"
```

-   문자열을 return 받을 수 있음 !

### #Any

-   타입을 알지 못할 때

```typescript
let notSure: any = 4;
```

비슷한 역할로는 #Object 가 존재한다.

#### Any와 Object의 차이점?

-   #any 는 메스드 사용가능
-   #Object 는 메서드 사용불가

### #void

-   어떤 타입도 존재할 수 없음
-   보통 함수의 반환값이 없을 때 사용

```typescript
const warnUser: void = () => {
    console.log("Warning!!");
};
```

### #Null and #undefined

```typescript
let u: undefined = undefined;
let n: null = null;
```

주의: #--strictNullChecks 를 사용하면, #Null 과 #undefined 는 오직 #Any 와 각자 자신들 타입에만 할당 가능하다.

-   #String 또는 #Null 또는 #undefined 를 사용하고 싶을 때 다음처럼 사용할 수 있다.

```typescript
type myType = number | null | undefined;
```

### #Never

-   절대 발생할 수 없는 타입

```typescript
// never를 반환하는 함수는 함수의 마지막에 도달할 수 없다.
function error(message: string): never {
    throw new Error(message);
}

// 반환 타입이 never로 추론된다.
function fail() {
    return error("Something failed");
}

// never를 반환하는 함수는 함수의 마지막에 도달할 수 없다.
function infiniteLoop(): never {
    while (true) {}
}
```

### 객체 ( #Object)

원시 타입이 아닌 타입을 나타낸다.

#### 원시 타입?

Ref: https://velog.io/@handaehee93/TypeScript-%EC%9B%90%EC%8B%9C-%ED%83%80%EC%9E%85-Primitive-Type

-   number, string, boolean, null, undefined, literal 등

```typescript
declare function create(o: object | null): void;

create({ prop: 0 }); // 성공
create(null); // 성공

create(42); // 오류
create("string"); // 오류
create(false); // 오류
create(undefined); // 오류
```

### 타입 단언 ( #Type Assertions)

-   컴파일러에게 "날 믿어, 난 내가 뭘 하고 있는지 알아"라고 "단언"하는 방법
-   다른 언어의 형 변환과 유사하지만, 특별한 검사를 하거나 재구성하진 않는다 => 런타임에 영향을 미치지 않고 컴파일러만 이를 사용함

```typescript
// angle-bracket method
let someValue: any = "this is a string";
let len: number = (<string>someValue).length;

// as
let someValue: any = "this is a string";
let len: number = (someValue as string).length;
```

-   뭐를 사용하든 상관 없지만, JSX에서는 #as 만 허용됨

### #let

-   Typescript에서는 var대신 let을 사용하는 걸 권고한다.
