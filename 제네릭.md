> 재사용 가능한 컴포넌트를 구축하는 것도 중요한 부분임

### 제네릭의 Hello World

``` typescript
// Echo function
function identity(arg: number): number {
	return arg;
}
```

``` typescript
function identity<T>(arg: T): T {
	return arg;
}
```

> [!note] any와 다른 점
> 인수의 타입을 캡처함 즉, any는 들어오는 값의 타입 잃지만, 제네릭을 사용하면 들어오는 인자의 type을 쉽게 알 수 있음

``` typescript
let output = identity<string>("myString"); // 출력 타입: string
```

>[!info] 팁!
><>를 주지 않아도 컴파일러가 타입을 유추할 수 있음

### 제네릭 타입 변수 작업

``` typescript
function loggingIdentity<T>(arg: T): T {
  console.log(arg.length); // 오류: T에는 .length 가 없습니다.
  return arg;
}
```

``` typescript
function loggingIdentity<T>(arg: T[]): T[] {
  console.log(arg.length); // 배열은 .length를 가지고 있습니다. 따라서 오류는 없습니다.
  return arg;
}
```

또는

``` typescript
function loggingIdentity<T>(arg: Array<T>): Array<T> {
  console.log(arg.length); // 배열은 .length를 가지고 있습니다. 따라서 오류는 없습니다.
  return arg;
}
```

다음과 같이 작성할 수 있다

### 제네릭 타입 (Generic Types)

``` typescript
interface GenericIdentityFn {
  <T>(arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: GenericIdentityFn = identity;
```

- 다음과 같이 제네릭 인터페이스를 만들 수 있음

### 제네릭 클래스

``` typescript
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

``` typescript
let stringNumeric = new GenericNumber<string>();
stringNumeric.zeroValue = "";
stringNumeric.add = function(x, y) { return x + y; };

console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
```

- 복잡한 객체도 가능

### 제네릭 제약조건

``` typescript
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // 오류: T에는 .length가 없습니다.
    return arg;
}
```

- 위에서 array가 아니기 때문에 length가 있을거라고 확실하지 않음 => ERROR

``` typescript
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // 이제 .length 프로퍼티가 있는 것을 알기 때문에 더 이상 오류가 발생하지 않습니다.
    return arg;
}

loggingIdentity({length: 10, value: 3});
```

- length가 어떤 것인지 명시함으로써 오류를 해결

>[!note] 중요
>T라는 제네릭 타입에 extends를 통해 T라는 Type은 length라는 number 값을 지닌 프로퍼티가 있음을 정의함

### 제네릭 제약조건에서 타입 매개변수 사용

``` typescript
function getProperty<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, "a"); // 성공
getProperty(x, "m"); // 오류: 인수의 타입 'm' 은 'a' | 'b' | 'c' | 'd'에 해당되지 않음.
```

- 나중에 유틸리티에 대해 공부하고 다시 보기

### 제네릭에서 클래스 타입 사용

``` typescript
class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function createInstance<A extends Animal>(c: new () => A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;  // 타입검사!
createInstance(Bee).keeper.hasMask;   // 타입검사!
```

- BeeKeeper: hasMask(boolean)
- ZooKeeper: nametag(string)
- Animal: numLegs(number)
- Bee: keeper(BeeKeeper) + numLegs(number)
- Lion: keeper(ZooKeeper) + numLegs(number)

- createInstance: A: Animal + a

``` typescript
createInstance(Lion) // Lion 객체 생성
createInstance(Lion).keeper // ZooKeeper
createInstance(Lion).keeper.nametag // string type
```

