Named Function과 Anonymous Function이 있다.

``` typescript
// 기명함수
function add(x, y) { 
	return x + y;
}

// 익명 함수
let myAdd = function(x, y) {return x + y};
```


- 함수는 함수 외부의 변수를 참조할 수 있다. 이런  것을 #캡쳐 라고 한다

### 함수 타입

``` typescript
function add(x: number, y: number): number {
	return x + y;
}

let myAdd = function(x: number, y: number): number {return x + y};
```

- 자신의 반환될 타입을 정할 수도 있다. 하지만, 반환문을 보고 반환 타입을 파악할 수 있으므로 반환 타입을 생략할 수도 있다

### 함수 타입 지정하기

``` typescript
let myAdd: (x: number, y: number) => number 
	= function(x: number, y: number): number {return x + y}
```

- 저 두 x, y의 이름은 달라도 된다.
- 그저 매개변수의 타입들이 올바르게 나열되어 있는지만 보면 됨

### 타입 추론

``` typescript
// myAdd는 전체 함수 타입을 가집니다
let myAdd = function(x: number, y: number): number { return  x + y; };

// 매개변수 x 와 y는 number 타입을 가집니다
let myAdd: (baseValue: number, increment: number) => number =
    function(x, y) { return x + y; };
```

### 선택적 매개변수와 기본 매개변수

``` typescript
function buildName(firstName: string, lastName: string) {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // 오류, 너무 적은 매개변수
let result2 = buildName("Bob", "Adams", "Sr.");  // 오류, 너무 많은 매개변수
let result3 = buildName("Bob", "Adams");         // 정확함
```

- 자바스크립트에서는 위의 구문들이 가능하며, undefined 값으로 들어간다
- 이러한 기능을 "?"로 선택적 매개변수로 만들 수 있다.

``` typescript
function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
}
```

- 매개변수에 기본값을 줄 수 있다.
- 선택적 매개변수는 뒤에 와야 하지만, 기본 매개변수는 뒤에 와야 하는 제약이 없다.

### 나머지 매개변수

``` typescript
function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + " " + restOfName.join(" ");
}

// employeeName 은 "Joseph Samuel Lucas MacKinzie" 가 될것입니다.
let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
```

- 나머지 매개변수는 몇개가 들어오든 상관없음

### #this 와 화살표 함수

``` typescript
let deck = {
	suits = ["hearts", "spades", "clubs", "diamonds"],
	cards: Array(52),
	createCardPicker: function() {
		return function() {
			let pickedCard = Math.floor(Math.random() * 52);
			let pickedSuit = Math.floor(pickedCard / 13);

			return {suit: this.suits[pickedSuit], card: pickedCard % 13};
		}
	}
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card " + pickedCard.card + " of " + pickedCard.suit);
```

- 오류가 발생한다
- createCardPicker 에 의해 생성된 함수에서 사용 중인 this가 deck 객체가 아닌 window에 설정되었기 때문입니다.

``` typescript
let deck = {
	suits: ["hears", "spades", "clubs", "diamonds"],
	cards: Array(52),
	createCardPicker(): function() {
		// arrow function을 사용하면
		// 'this'를 이곳에서 캡처할 수 있음
		return () => {
			let pickedCard = Math.floor(Math.random() * 52);
			let pickedSuit = Math.floor(pickedCard / 13);

			return {suit: this.suits[pickedSuit], card: pickedCard % 13};
		}
	}
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
```

- this는 any type이다.

### this 매개변수

- 아직까지 this.suits[pickedSuit]의 타입은 여전히 any이다

``` typescript
interface Card {
    suit: string;
    card: number;
}
interface Deck {
    suits: string[];
    cards: number[];
    createCardPicker(this: Deck): () => Card;
}
let deck: Deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    // NOTE: 아래 함수는 이제 callee가 반드시 Deck 타입이어야 함을 명시적으로 지정합니다.
    createCardPicker: function(this: Deck) {
        return () => {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
```

### #오버로드

``` typescript
function pickCard(x: {suit: string; card: number; }[]): number;
function pickCard(x: number): {suit: string; card: number; };
function pickCard(x): any {
    // 인자가 배열 또는 객체인지 확인
    // 만약 그렇다면, deck이 주어지고 card를 선택합니다.
    if (typeof x == "object") {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }
    // 그렇지 않다면 그냥 card를 선택합니다.
    else if (typeof x == "number") {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}
```

주의
- function pickCard(x): any는 오버로드 목록에 해당되지 않는다

