##### Typescript 핸드북 study.log

# 함수

## 1. 기본 개념

함수는 JS 애플리케이션의 기본 구성 요소이다. Typescript에서는 표준 Javascript 함수가 작업을 수월하게 하도록 몇 가지 새로운 기능을 추가한다.  
<br>Typescript 함수는 기명 함수(named function) 또는 익명 함수(anonymous function)로 만들 수 있다.

```typescript
// 기명 함수
function add(x, y) {
  return x + y;
}

// 익명 함수
let myAdd = function (x, y) {
  return x + y;
};
```

<br>JS에서와 동일하게, 함수는 함수 외부의 변수를 참조할 수 있다. 이때 변수를 **_캡처(capture)_**한다고 한다.

```typescript
let z = 100;

function addToZ(x, y) {
  return x + y + z;
}
```

<br>

## 2. 함수 타입

### 함수의 타이핑(Typing the function)

함수의 각 파라미터와 반환타입을 정해줄 수 있다. 이때 Typescript에서 `return`문을 보고 반환 타입을 추정할 수 있어 반환 타입은 명시적으로 적지 않고 생략할 수 있다.  
<br>각 파라미터의 타입은 콜론(`:`)을 이용해서 명시하고, 반환 타입은 파라미터와 동일한 방법으로 명시하거나, 화살표 표기(`=>`)를 이용해서 분명하게 명시할 수 있다. 만약 반환 값이 없을 경우, 비워두는 대신 `void`로 명시한다.

```typescript
// 콜론(:) 이용
function add(x: number, y: number): number {
  return x + y;
}

let myAdd = function (x: number, y: number): number {
  return x + y;
};

// 화살표 표기
let myAdd: (x: number, y: number) => number = function (
  x: number,
  y: number
): number {
  return x + y;
};
```

참고로, 위에서 언급한 '캛처된 변수'의 경우 타입에 반영되지 않음.  
<br>

### 타입의 추론 (Inferring the types)

아래 예제처럼, 방정식의 한쪽에만 타입이 명시되어 있어도 Typescript 컴파일러는 스스로 반환값의 타입을 알아낼 수 있다.

```typescript
let myAdd = function (x: number, y: number): number {
  return x + y;
};

let myAdd: (x: number, y: number) => number = function (x, y) {
  return x + y;
};
```

이러한 타입 추론 형태를 `contextual typing`이라고 부른다.  
<br>

## 3. 선택적 매개변수와 기본 매개변수 (Optional and Default Parameter)

Typescript에서는 모든 매개변수가 함수에 필요하다고 가정한다. 즉 함수 호출 시 컴파일러는 함수에 정의된 모든 매개변수를 사용자가 제공했는지, 정의되지 않은 매개변수를 전달하지는 않았는지 검사한다.  
즉, 사용자가 함수를 호출하며 전달하는 매개변수와 함수가 기대하는 매개변수가 일치해야 한다.  
<br>JS에서는 모든 매개변수가 선택적이고, 값을 전달하지 않은 채로 두면 `undefined`가 된다. Typescript에서도 매개변수 이름 끝에 `?`를 붙여 **optional**한 매개변수라는 것을 전달할 수 있다.

```typescript
function koreanName1(lastName: string, firstName: string) {
  return lastName + " " + firstName;
}

let res1 = koreanName1("Han"); // 오류: 너무 적은 매개변수
let res2 = koreanName1("Han", "Ji", "Woo"); // 오류: 너무 많은 매개변수
let res3 = koreanName1("Han", "Ji-woo"); // 성공

// firstName을 optional하게 설정
function koreanName2(lastName: string, firstName?: string) {
  if (firstName) {
    return lastName + " " + firstName;
  } else {
    return lastName;
  }
}

let res1 = koreanName2("Han"); // 지금은 바르게 동작
let res1 = koreanName2("Han", "Ji", "Woo"); // 오류: 너무 많은 매개변수
let res1 = koreanName2("Han", "Ji-Woo"); // 성공
```

lastName 대신 firstName을 `optional`하게 설정하고 싶다면 매개변수의 순서를 변경하면 된다.  
<br>Typescript에서는 유저가 값을 제공하지 않거나, `undefined`로 했을 대 할당될 매개변수의 값을 미리 정해 놓을 수 있는데, 이것을 `기본-초기화 매개변수`라고 한다. 아래 예시는 `lastName`을 미리 지정한 함수이다.

```typescript
function koreanName(firstName: string, lastName = "Kim") {
  return lastName + " " + firstName;
}

let res1 = koreanName("Jiwoo"); // 성공: Kim Jiwoo 반환
let res2 = koreanName("Jiwoo", undefined); // 성공: Kim Jiwoo 반환
let res3 = koreanName("Han", "Ji", "Woo"); // 오류: 너무 많은 매개변수
let res4 = koreanName("Han", "Jiwoo"); // 성공: Han Jiwoo 반환
```

모든 필수 매개변수 뒤에 오는 `기본-초기화 매개변수`는 선택적으로 처리되며, 생략 가능하다. 때문에 위의 두 예제에서 함수 `koreanName2`와 `koreanName`은 `(firstName: string, lastName?: string) => string`라는 공통된 타입을 공유한다.  
<br>'`?`' 를 이용한 선택적 매개변수의 경우와 다르게, `기본-초기화 매개변수`는 필수 매개변수 뒤에 붙일 필요가 없다. 필수 매개변수가 뒤로 가게 된다면 사용자가 명시적으로 `undefined`를 전달해 주어야 기본적으로 설정된 매개변수의 값을 볼 수 있다.

```typescript
function koreanName(lastName = "Kim", firstName: string) {
  return lastName + " " + firstName;
}
let result = koreanName(undefined, "Jiwoo"); // "Kim Jiwoo" 반환
```

## 4. 나머지 매개변수 (Rest Parameters)

다수의 매개변수를 받아서 작업하거나, 최종적으로 함수가 받을 매개변수의 갯수를 모르는 경우에는 이 인자들을 하나의 변수로 모을 수 있다. _나머지 매개변수_ 는 선택적 매개변수의 수를 무한으로 취급한다.  
<br>나머지 매개변수로 인자를 넘겨줄 때는 갯수에 제한이 없고, 아무것도 넘겨주지 않을 수도 있다. 생략 부호(`...`)뒤에 인자 배열을 전달하는 방식으로 사용할 수 있다.

```typescript
function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
}
```

## 5. `this`

### `this`와 화살표 함수 (this and arrow functions)

Javascript에서 `this`는 함수 호출 시에 정해지는 변수다. 사용하는 법을 알면 유연하고 편리하게 쓸 수 있지만, 함수가 실행되는 컨텍스트에 대해 잘 모르면 사용하기 쉽지 않다.

```typescript
let deck = {
  suits: ["hearts", "spades", "clubs", "diamonds"],
  cards: Array(52),
  createCardPicker: function () {
    return function () {
      let pickedCard = Math.floor(Math.random() * 52);
      let pickedSuit = Math.floor(pickedCard / 13);

      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
    };
  },
};

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
```

<br>위 예제 코드를 실행하면 오류가 발생한다. `createCardPicker`에 의해 생성된 함수에서 `this`가 `deck` 객체가 아닌 `window`에 설정되었기 때문이다. 이는 최상위 레벨에서 `cardPicker()`를 자체적으로(비-메서드 문법으로) 호출했기 때문인데, ES6의 화살표 함수를 이용해서 이를 해결할 수 있다. 화살표 함수는 함수가 호출된 쪽이 아닌 행성된 쪽의 `this`를 캡처한다.

```typescript
let deck = {
  // ...
  createCardPicker: function () {
    return function () {
      return () => {
        let pickedCard = Math.floor(Math.random() * 52);
        let pickedSuit = Math.floor(pickedCard / 13);

        return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
        // 이때 this의 type은 any이다.
      };
    };
  },
};
```

### `this` 매개변수 (this parameter)

이전 예제에서, `this.suits[pickedSuit]`의 타입이 `any`라고 언급했는데, 이는 `this`가 객체 리터럴 내부의 함수에서 왔기 때문이다. 이를 고치기 위해 명시적으로 `this` 매개변수를 줄 수 있다. 이때 `this` 매개변수는 함수의 매개변수 목록에서 가장 먼저 나오는 **가짜** 매개변수이다.

```typescript
interface Card {
  suit: string;
  card: number;
}
interface Deck {
  suits: string[];
  cards: number[];
  createCardPicker(this: Deck): () => Card;
}

let deck: Deck = {
  suits: ["hearts", "spades", "clubs", "diamonds"],
  cards: Array(52),
  // createCardPicker가 Deck 객체에서 호출됨을 명시
  createCardPicker: function (this: Deck) {
    return () => {
      let pickedCard = Math.floor(Math.random() * 52);
      let pickedSuit = Math.floor(pickedCard / 13);

      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };
    };
  },
};
```

### 콜백에서 `this` 매개변수 (this parameters in callbacks)

콜백 함수를 라이브러리에 전달할 때 `this` 때문에 오류가 발생할 수 있는데, 라이브러리는 콜백을 일반 함수처럼 호출하므로 `this`는 `undefined`가 된다.  
일부 작업에서 콜백 오류를 막기 위해 `this`를 사용할 수 있는데, 먼저 콜백 타입을 `this`로 표시해줘야 한다.

```typescript
interface UIElement {
  addClickListener(onclick: (this: void, e: Event) => void): void;
}
```

<br>`this: void`는 `addClickListener`가 `onclick`이 `this`타입을 요구하지 않는 함수가 될 것으로 예상한다는 것을 의미한다. 이후 다음과 같이 호출하면 오류가 발생한다.

```typescript
class Handler {
  info: string;
  onClickBad(this: Handler, e: Event) {
    // this로 인한 런타임 에러 발생
    this.info = e.message;
  }
}

let h = new Handler();
uiElement.addClickListener(h.onClickBad); // 오류
```

<br>`onClickBad`가 `Handler`의 인스턴스로써 호출됨을 명시해 주면 Typescript는 `addClickListener`가 `this: void`를 갖는 함수를 필요로 한다는 것을 감지한다. 오류 해결을 위해서 `this`의 타입을 바꿔 주도록 하자.

```typescript
class Handler {
  info: string;
  onClickGood(this: void, e: Event) {
    console.log("clicked!");
  }
}

let h = new Handler();
uiElement.addClickListener(h.onClickGood);
```

이렇게 작성하면 `this.info`를 사용할 수 없게 되는데, 만약 `this.info`를 사용하고 싶다면 화살표 함수를 사용하면 된다.

```typescript
class Handler {
  info: string;
  onClickGood = (e: Event) => {
    this.info = e.message;
  };
}
```

화살표 함수에서 이용하는 `this`와 Typescript에서 `void`일 것이라고 기대하는 `this`가 다르기 때문에, 위와 같은 코드는 에러를 발생시키지 않는다.

## 6. 오버로드 (Overloads)

하나의 함수가 전달된 인자의 형태에 따라 다른 타입의 객체를 반환하는 경우가 자주 있다. 이때 JS에서는 별 문제가 발생하지 않지만 Typescript에서는 타입 시스템이 걸림돌이 된다. 이러한 경우 오버로드 목록으로 동일한 함수에 다중 함수 타입을 제공하면 된다.  
<br>오버로드 목록은 컴파일러가 함수 호출들을 해결할 때 사용하는 것이다.

```typescript
let suits = ["hearts", "spades", "clubs", "diamonds"];

function pickCard(x: { suit: string; card: number }[]): number;
function pickCard(x: number): { suit: string; card: number };
function pickCard(x): any {
  // 인자가 배열 또는 객체인지 확인
  // 만약 그렇다면, deck이 주어지고 card를 선택
  if (typeof x == "object") {
    let pickedCard = Math.floor(Math.random() * x.length);
    return pickedCard;
  }
  // 그렇지 않다면 그냥 card 선택
  else if (typeof x == "number") {
    let pickedSuit = Math.floor(x / 13);
    return { suit: suits[pickedSuit], card: x % 13 };
  }
}
```

<br>위 예제에서 오버로드는 `pickCard`함수에 대해 타입 검사 호출을 제공한다. 오버로드 목록에서 첫 번째 오버로드부터 진행하며 제공된 매개변수를 사용하여 함수 호출을 시도한다. 만약 일치하게 된다면 해당 오버로드를 알맞은 오버로드로 선택하여 작업을 수행하는데, 이러한 이유로 가장 구체적인 것부터 리스팅하는 것이 일반적이다.  
<br>위 예제에서 `function pickCard(x): any`는 오버로드 목록에 포함되지 않는다. 오직 객체를 받는 것 하나와 숫자를 받는 것 하나. 총 두 가지의 오버로드만을 가진다. 다른 매개변수 타입으로 `pickCard`를 호출하면 오류가 발생한다.
