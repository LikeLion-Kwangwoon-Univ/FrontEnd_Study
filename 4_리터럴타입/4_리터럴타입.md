##### Typescript 핸드북 study.log

# 리터럴 타입

리터럴 타입은 집합 타입의 보다 구체적인 하위 타입이라고 할 수 있다. 비유하자면 `"Hello world"`는 `string`이지만, `string`은 `"Hello World"`가 아닌 것과 유사하다.  
<br>Typescript에는 문자열과 숫자 두 가지의 리터럴 타입이 있는데, 이를 사용하면 문자열이나 숫자에 정확한 값을 지정할 수 있다.

## 1. 리터럴 타입 좁히기 (Literal Narrowing)

`var` 또는 `let`으로 변수를 선언할 경우 이 변수의 값이 변경될 수 있음을 컴파일러에게 알린다. 반면 `const`로 변수를 선언할 경우 이 객체는 절대 변경되지 않음을 알린다.

```typescript
const helloWorld = "Hello World";

let hiWorld = "Hi World";
```

위 예제에서, `const`를 사용하여 변수 `helloWorld`가 절대 변경되지 않음을 명시했기 때문에, Typescriptsms `helloWorld`의 타입을 `"Hello World"`라고 정한다.  
<br>반면, `let`은 변경될 수 있으므로 `hiWorld`의 타입은 그대로 문자열이 될 것이다.  
<br>이와 같이 무한한 수의 잠재적 케이스들을 유한한 수의 잠재적 케이스(`helloWorld`의 경우에는 1개)로 줄여나가는 것을 **타입 좁히기**라고 한다.

## 2. 문자열 리터럴 타입 (String Literal Types)

문자열 리터럴 타입은 유니언 타입, 타입 가드, 그리고 타입 별칭과 잘 결합된다. 이러한 기능을 함께 사용하면 문자열로 `enum`과 비슷한 형태를 갖출 수 있다.

```typescript
// @errors: 2345
type Easing = "ease-in" | "ease-out" | "ease-in-out";

class UIElement {
  animate(dx: number, dy: number, easing: Easing) {
    if (easing === "ease-in") {
      ///...
    } else if (easing === "ease-out") {
    } else if (easing === "ease-in-out") {
    } else {
      // 허용되지 않은 타입 이용시 도달
    }
  }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy"); // 오류 발생
```

허용된 세 가지의 문자열 "ease-in", "ease-out", "ease-in-out"이 아닌 다른 문자열을 사용하게 되면 오류가 발생한다.  
<br>또한 문자열 리터럴 타입은 오버로드와 동일한 방법으로 사용될 수 있다.

```typescript
function createElement(tagName: "img"): HTMLImageElement;
function createElement(tagName: "input"): HTMLInputElement;
// ...
function createElement(tagName: string): Element {
  // ...
}
```

## 3. 숫자형 리터럴 타입 (Numeric Literal Types)

위의 문자열 리터럴과 같은 역할을 하는 숫자형 리터럴 타입도 있는데, 주로 설정값을 설명할 때 사용된다.

```typescript
function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {
  return (Math.floor(Math.random() * 6) + 1) as 1 | 2 | 3 | 4 | 5 | 6;
}

const result = rollDice();
```
