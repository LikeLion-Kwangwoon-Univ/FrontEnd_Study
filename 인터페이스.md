### #interface

```typescript
interface LabeledValue {
    label: string;
}

function printLabel(labeledObj: LabeledValue) {
    console.log(labeledObj.label);
}

let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);
```

Compiler의 검사

-   label이라는 property를 가지고 있나 ?
-   label이라는 property가 sting인가 ?

### 선택적 프로퍼티 (Optional Properties)

-   모든 property가 필요한 것이 아닌 어떤 조건에서만 존재하거나 없을 수 있다.

```typescript
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    let newSquare = { color: "white", area: 100 };
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({ color: "black" });
```

-   createSquare의 인자 값으로는 SquareConfig같은 조건을 만족시켜야 한다.
    1.  color가 있나?
    2.  width가 있나?
-   하지만, 모든 조건을 만족시키지 않아도 된다.
    1.  color가 있으면 걔는 string이어야 해
    2.  width가 있으면 걔는 number여야 해
-   함수의 return value로는 객체가 return 되어야 하는데
    1.  color와 area라는 property를 가지고 있으며,
    2.  color는 string이고,
    3.  area는 number어야 해

### 읽기전용 프로퍼티 ( #Readonly)

-   초기화만 하고, 수정이 불가능하다.

```typescript
interface Point {
    readonly x: number;
    readonly y: number;
}

let p1: Point = { x: 10, y: 20 };
p1.x = 5; // ERROR!!
```

### #ReadonlyArray

```typescript
let roArray: ReadonlyArray<number> = [1, 2, 3, 4];
```

### #Readonly vs #const

-   변수: #const
-   프로퍼티: #Readonly

### 초과 프로퍼티 검사 (Excess Property Checks)

```typescript
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });
```

-   color가 들어가야 할 자리에 colour라고 들어갔다.

    -   ERROR를 출력함

-   이걸 ERROR를 안 띄울 수는 없을까 ?

#### Sol1 ) 타입 단언

[[기본 타입]] -> 타입 단언 검색

```typescript
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

#### Sol2 ) 프로퍼티 추가

```typescript
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

#### Sol3 ) 변수 할당

```typescript
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```

-   공통된 것만 인자로 전달됨
    -   width가 될 것임

### 함수 타입 (Function Types)

```typescript
interface SearchFunc {
    (source: string, subString: string): boolean;
}
```

#interface 를 통해 함수의 인자, return 타입을 정의할 수 있음

-   첫 번째 인자는 string
-   두 번째 인자는 string
-   return value는 boolean으로 만들어

```typescript
let mySearch: SearchFunc;
mySearch = function (src: string, sub: string): boolean {
    let result = src.search(sub);
    return result > -1;
};
```

이렇게 직접 할당해서 사용하면 됨

-   매개변수의 이름이 같을 필요는 없다.
-   같은 위치에 대응하는 매개변수끼리 하나씩 검사

### 인덱서블 타입 (Indexable Types)

```typescript
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
```

-   StringArray
    -   index로 number를 받는다
    -   string을 return한다

이러한 interface를 #index #signature 라고 부른다

이런 Index Signature을 지원하는 타입으로는 두 가지가 있다.

-   문자열
-   숫자

두 타입의 인덱서를 모두 지원하는 것은 가능하지만, 숫자 인덱서에서 반환된 타입은 반드시 문자열 인덱서에서 반환된 타입의 하위 타입이어야 한다.

Javascript에서 객체를 인덱싱할 때 string으로 변환하기 때문이다.

```javascript
const myArr = [1, 2, 3];

const myArr = {
    0: 1,
    1: 2,
    2: 3,
};
```

따라서 다음과 같을 때 에러를 발생시킨다

```typescript
interface dict {
    [index: string]: number;
    length: number;
    name: string;
}
```

**모든 프로퍼티들이 반환 타입과 일치하도록 해야 한다**

```typescript
interface NumberDictionary {
    [index: string]: number;
    length: number; // 성공, length는 숫자입니다
    name: string; // 오류, `name`의 타입은 인덱서의 하위타입이 아닙니다
}
```

합집합이면 가능

```typescript
interface NumberOrStringDictionary {
    [index: string]: number | string;
    length: number; // 성공, length는 숫자입니다
    name: string; // 성공, name은 문자열입니다
}
```

readonly로 할당을 막을 수 있음

```typescript
interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // 오류!
```

### 클래스 타입 (Class Types)

#### #implementing an interface

```typescript
interface ClockInterface {
    curTime: Date;
    setTime(d: Date): void;
}

class Clock implements ClockInterface {
    curTime: Date = new Date();
    setTime(d: Date) {
        this.curTime = d;
    }
    constructor(h: number, m: number) {}
}
```

### 인터페이스 확장하기

```typescript
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
```

### 하이브리드 타입

```typescript
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = function (start: number) {} as Counter;
    counter.interval = 123;
    counter.reset = function () {};
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

-   Counter 객체를 만들어 직접 property를 넣는 것을 하이브리드라고 한다.

### 클래스를 확장한 인터페이스

URL
https://yamoo9.gitbook.io/typescript/interface/extends

-   인터페이스 타입이 클래스 타입을 확장하면, 클래스의 맴버는 상속받지만 구현은 상속받지 않는다.
-   인터페이스는 심지어 private, protected 맴버도 상속받는다.

```typescript
class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() {}
}

class TextBox extends Control {
    select() {}
}

// Error: Property 'state' is missing in type 'Image'.
class Image implements SelectableControl {
    private state: any;
    select() {}
}

class Location {}
```

-   Button
    -   private이기 때문에 직접 접근할 수 없음
    -   select는 return 값이 void여야 하며, 인자값이 없어야 함
-   TextBox
    -   private이기 때문에 직접 접근할 수 없음
    -   select는 어떤 함수가 들어와도 됨
