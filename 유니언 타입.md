``` typescript
function padLeft(value: string, padding: any) {
	if (typeof padding === "number") {
		return Array(padding + 1).join(" ") + value;
	}
	if (typeof padding === "string") {
		return padding + value;
	}
	throw new Error(`Expected string or number, got '${padding}'.`);
}

padLeft("Hello world", 4);
```

- number나 string을 매개변수로 기대하는 다음과 같은 함수를 사용하는 라이브러리가 있다고 가정해보자.

``` typescript
declare function padLeft(value: string, padding: any): string;

// 컴파일 타임에는 통과, 하지만 런타임에는 오류
let indentedString = padLeft("Hello world", true);
```

- padding은 any type이기 때문에 실행하기 전인 컴파일 타임에는 통과하지만, 런타임 내에서는 에러가 발생함


이를 해결하기 위해 #union type을 사용할 수 있다.

``` typescript
function padLeft(value: string, padding: string | number);

let indentedString = padLeft("Hello world", true);
```

### 공통 필드를 갖는 유니언

``` typescript
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

declare function getSmallPet(): Fish | Bird;

let pet = getSmallPet();
pet.layEggs();

pet.swim(); // ERROR!!
```

>[!danger] 주의
>pet은 공통된 부분은 layEggs만 사용할 수 있음
>> 유니언에 있는 모든 타입에 공통인 멤버들에만 접근할 수 있다.

>[!info] 정리
>A | B 타입을 갖고 있다면 A, B 둘 다 가지고 있는 멤버들을 갖고 있다는 것임

### 유니언 구별하기

```typescript
type NetworkLoadingState = {
  state: "loading";
};

type NetworkFailedState = {
  state: "failed";
  code: number;
};

type NetworkSuccessState = {
  state: "success";
  response: {
    title: string;
    duration: number;
    summary: string;
  };
};

// 위 타입들 중 단 하나를 대표하는 타입을 만들었지만,
// 그것이 무엇에 해당하는지 아직 확실하지 않습니다.
type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState;
```

- 공통적인 state type을 가지고 있지만, 어떠한 값인지 모름 => switch case문 사용

``` typescript
function networkStatus(status: NetworkState): string {
	switch(state.state) {
		case "loading":
			handleFunc();
		case "failed":
			handleFunc();
		case "success":
			handleFunc();
	}
}
```

### #교차타입

> 교차 타입은 유니언 타입과 밀접한 관련이 있지만, 사용 방법이 매우 다르다.
> 여러 타입을 하나로 결합한다

``` typescript
interface ErrorHandling {
  success: boolean;
  error?: { message: string };
}

interface ArtworksData {
  artworks: { title: string }[];
}

interface ArtistsData {
  artists: { name: string }[];
}

type ArtworksResponse = ArtworksData & ErrorHandling;
type ArtistsResponse = ArtistsData & ErrorHandling;

const handleArtistsResponse = (response: ArtistsResponse) => {
  if (response.error) {
    console.error(response.error.message);
    return;
  }

  console.log(response.artists);
};
```

> [!info] 정리
> ArtworksResponse: ArtworksData (artworks) + ErrorHandling (success, error)
> => arkworks + success + error
> ArtistsResponse: ArtistsData (artists) + ErrorHandling (success, error)
> => artists + success + error

### 교차를 통한 믹스인

``` typescript
class Person {
  constructor(public name: string) {}
}

interface Loggable {
  log(name: string): void;
}

class ConsoleLogger implements Loggable {
  log(name: string) {
    console.log(`Hello, I'm ${name}.`);
  }
}

// 두 객체를 받아 하나로 합칩니다. -> Mixin
function extend<First extends {}, Second extends {}>(
  first: First,
  second: Second
): First & Second {
  const result: Partial<First & Second> = {};
  for (const prop in first) {
    if (first.hasOwnProperty(prop)) {
      (result as First)[prop] = first[prop];
    }
  }
  for (const prop in second) {
    if (second.hasOwnProperty(prop)) {
      (result as Second)[prop] = second[prop];
    }
  }
  return result as First & Second;
}

const jim = extend(new Person("Jim"), ConsoleLogger.prototype);
jim.log(jim.name);
```

##### Ref
[[제네릭]]

